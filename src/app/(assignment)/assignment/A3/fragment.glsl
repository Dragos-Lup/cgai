uniform float iTime;
uniform vec2 iResolution;

//======================================================= Copy-Paste Area Begin =========================================================

// Number of Gaussians
const int NUM_GAUSSIANS = 100;
// Dimensions [x_min, x_max, y_min, y_max]
float dim[4] = float[4](-5.0,5.0,-5.0,5.0);
// Centers (x, y coordinates)
vec2 gauss_centers[NUM_GAUSSIANS] = vec2[NUM_GAUSSIANS](vec2(3.57, -3.49),vec2(2.97, -4.87),vec2(-0.68, 3.46),vec2(2.06, -5.79),vec2(3.90, 3.49),vec2(-3.61, -1.93),vec2(-5.08, 4.54),vec2(-4.33, -1.53),vec2(-3.86, 4.51),vec2(-2.48, -3.01),vec2(-2.03, 3.73),vec2(4.81, -2.18),vec2(3.04, 3.07),vec2(2.06, 3.09),vec2(-3.38, 3.27),vec2(5.21, -0.71),vec2(-4.46, 5.08),vec2(-5.74, 1.36),vec2(1.31, -5.10),vec2(1.98, -0.94),vec2(3.97, -0.37),vec2(-3.09, -5.60),vec2(4.86, -4.73),vec2(2.68, -0.86),vec2(1.36, 0.29),vec2(0.41, -2.67),vec2(1.54, -2.14),vec2(4.73, 2.97),vec2(2.70, 0.09),vec2(-0.40, -3.31),vec2(-1.04, -5.62),vec2(-1.38, 4.96),vec2(2.05, -0.30),vec2(-2.59, 0.26),vec2(-4.83, 3.23),vec2(-1.01, -0.64),vec2(4.11, -1.54),vec2(-1.98, -4.76),vec2(0.50, 4.69),vec2(0.71, 1.81),vec2(0.22, 4.63),vec2(-4.83, -5.78),vec2(-1.20, 4.43),vec2(2.19, -3.68),vec2(-2.97, -0.97),vec2(-2.03, 1.05),vec2(-0.88, -2.20),vec2(-3.40, -0.77),vec2(2.54, -1.61),vec2(-3.60, -3.11),vec2(3.76, -1.95),vec2(4.87, 4.74),vec2(-2.73, -0.32),vec2(1.73, 1.14),vec2(2.67, -2.55),vec2(1.36, 2.32),vec2(2.26, 2.39),vec2(-2.76, 4.69),vec2(0.62, 3.24),vec2(-4.87, -2.75),vec2(3.44, -1.30),vec2(-3.87, -0.16),vec2(-0.66, 0.33),vec2(0.72, -3.80),vec2(2.78, 0.81),vec2(5.09, -3.15),vec2(-1.26, -3.60),vec2(5.11, 2.22),vec2(3.93, 2.27),vec2(-4.63, 2.14),vec2(-0.24, 2.30),vec2(-0.05, -0.68),vec2(-3.04, -4.25),vec2(-3.33, 1.95),vec2(1.23, 4.23),vec2(1.53, -3.24),vec2(-3.70, 1.06),vec2(-4.88, 5.37),vec2(2.72, 1.38),vec2(5.09, 3.70),vec2(-0.46, -4.92),vec2(4.74, 1.08),vec2(1.93, 4.83),vec2(3.71, 0.10),vec2(-2.16, -1.61),vec2(-2.85, 1.86),vec2(-3.68, 1.58),vec2(-3.46, 3.08),vec2(0.15, -6.13),vec2(2.64, 2.13),vec2(-1.23, 2.03),vec2(-5.01, -0.30),vec2(-4.32, -4.27),vec2(3.21, 4.56),vec2(1.79, 3.71),vec2(0.68, -1.51),vec2(1.96, 0.42),vec2(-2.56, 2.77),vec2(0.42, 3.88),vec2(0.44, 0.65));
// Sigmas (scales)
vec2 gauss_sigmas[NUM_GAUSSIANS] = vec2[NUM_GAUSSIANS](vec2(0.60, 0.64),vec2(0.68, 0.58),vec2(0.54, 0.37),vec2(0.23, 0.34),vec2(0.39, 0.52),vec2(0.68, 0.58),vec2(0.65, 0.50),vec2(0.68, 0.28),vec2(0.51, 0.50),vec2(0.63, 0.68),vec2(0.47, 0.20),vec2(0.42, 0.11),vec2(0.39, 0.61),vec2(0.27, 0.31),vec2(0.52, 0.23),vec2(0.51, 0.86),vec2(0.41, 0.12),vec2(0.57, 0.55),vec2(0.76, 0.63),vec2(0.69, 0.45),vec2(0.67, 0.58),vec2(0.73, 0.48),vec2(0.71, 0.76),vec2(0.46, 0.15),vec2(0.43, 0.53),vec2(0.61, 0.58),vec2(0.50, 0.73),vec2(0.50, 0.38),vec2(0.37, 0.43),vec2(0.38, 0.59),vec2(0.24, 0.28),vec2(0.41, 0.62),vec2(0.53, 0.21),vec2(0.64, 0.35),vec2(0.68, 0.49),vec2(0.45, 0.37),vec2(0.41, 0.08),vec2(0.62, 0.73),vec2(0.49, 0.32),vec2(0.53, 0.51),vec2(0.61, 0.14),vec2(0.51, 0.45),vec2(0.62, 0.12),vec2(0.63, 0.65),vec2(0.70, 0.30),vec2(0.36, 0.56),vec2(0.65, 0.70),vec2(0.62, 0.08),vec2(0.43, 0.53),vec2(0.52, 0.52),vec2(0.55, 0.74),vec2(0.68, 0.52),vec2(0.17, 0.23),vec2(0.33, 0.30),vec2(0.61, 0.55),vec2(0.22, 0.54),vec2(0.20, 0.49),vec2(0.68, 0.54),vec2(0.65, 0.33),vec2(0.63, 0.73),vec2(0.37, 0.18),vec2(0.55, 0.27),vec2(0.48, 0.55),vec2(0.69, 0.67),vec2(0.53, 0.45),vec2(0.83, 0.70),vec2(0.55, 0.66),vec2(0.57, 0.44),vec2(0.43, 0.49),vec2(0.65, 0.34),vec2(0.34, 0.56),vec2(0.39, 0.42),vec2(0.60, 0.61),vec2(0.22, 0.27),vec2(0.32, 0.19),vec2(0.37, 0.31),vec2(0.68, 0.39),vec2(0.44, 0.24),vec2(0.30, 0.43),vec2(0.55, 0.40),vec2(0.73, 0.73),vec2(0.81, 0.61),vec2(0.43, 0.38),vec2(0.47, 0.12),vec2(0.68, 0.68),vec2(0.26, 0.54),vec2(0.11, 0.40),vec2(0.49, 0.63),vec2(0.24, 0.24),vec2(0.29, 0.39),vec2(0.45, 0.68),vec2(0.61, 0.61),vec2(0.67, 0.71),vec2(0.66, 0.74),vec2(0.40, 0.24),vec2(0.63, 0.46),vec2(0.41, 0.31),vec2(0.28, 0.49),vec2(0.67, 0.21),vec2(0.59, 0.42));
// Rotation angles (thetas)
float gauss_thetas[NUM_GAUSSIANS] = float[NUM_GAUSSIANS](0.20,-0.29,0.60,0.10,-0.66,0.37,-0.24,0.62,-0.15,0.09,0.61,-0.61,0.22,0.08,0.13,-0.16,0.33,-0.16,0.13,-0.25,0.45,-0.21,0.06,-0.52,0.05,0.04,-0.15,-0.13,-0.33,0.27,-0.05,-0.67,-0.03,-0.25,0.10,-0.38,-0.61,0.03,-0.20,0.31,-0.16,0.07,0.52,-0.05,0.16,0.14,-0.10,0.32,-0.76,0.02,0.93,0.15,-0.17,-0.27,-0.20,0.11,-0.16,-0.78,0.06,-0.33,-0.56,-0.24,0.66,-0.03,-0.38,-0.84,0.35,0.07,0.37,-0.08,-0.27,0.01,-0.14,0.37,-0.63,-0.08,-0.10,0.42,0.11,-0.47,-0.04,0.23,-0.67,-0.07,0.07,0.23,0.38,-0.45,-0.01,-0.02,0.25,0.46,0.22,-0.44,-0.66,0.60,0.72,-0.34,-0.08,0.35);
// Colors (RGB)
vec3 gauss_colors[NUM_GAUSSIANS] = vec3[NUM_GAUSSIANS](vec3(0.01, 0.24, 0.34),vec3(0.01, 0.28, 0.40),vec3(0.60, 0.42, 0.34),vec3(0.31, 0.49, 0.67),vec3(0.13, 0.25, 0.28),vec3(0.01, 0.31, 0.40),vec3(0.13, 0.22, 0.18),vec3(-0.02, 0.25, 0.27),vec3(0.17, 0.18, 0.15),vec3(0.01, 0.27, 0.34),vec3(0.41, 0.32, 0.25),vec3(0.54, 0.61, 0.61),vec3(0.08, 0.22, 0.24),vec3(0.74, 0.65, 0.59),vec3(-0.10, -0.16, -0.18),vec3(0.36, 0.39, 0.29),vec3(0.22, 0.52, 0.60),vec3(0.26, 0.66, 0.36),vec3(0.01, 0.28, 0.39),vec3(-0.02, 0.20, 0.27),vec3(0.25, 0.26, 0.21),vec3(-0.01, 0.41, 0.55),vec3(0.02, 0.27, 0.40),vec3(0.66, 0.61, 0.55),vec3(0.39, 0.38, 0.33),vec3(0.01, 0.20, 0.27),vec3(0.01, 0.22, 0.29),vec3(0.22, 0.24, 0.20),vec3(0.73, 0.66, 0.63),vec3(0.01, 0.13, 0.16),vec3(0.56, 0.38, 0.38),vec3(0.19, 0.25, 0.18),vec3(0.44, 0.31, 0.20),vec3(0.44, 0.40, 0.32),vec3(0.26, 0.28, 0.24),vec3(0.43, 0.42, 0.35),vec3(0.72, 0.58, 0.53),vec3(0.01, 0.23, 0.30),vec3(0.22, 0.32, 0.26),vec3(0.66, 0.43, 0.38),vec3(0.78, 0.62, 0.61),vec3(0.06, 0.87, 1.18),vec3(0.60, 0.53, 0.50),vec3(0.01, 0.26, 0.38),vec3(-0.01, 0.24, 0.27),vec3(0.47, 0.45, 0.39),vec3(-0.00, 0.21, 0.31),vec3(0.67, 0.50, 0.47),vec3(0.01, 0.17, 0.23),vec3(0.00, 0.20, 0.27),vec3(-0.01, 0.33, 0.44),vec3(0.24, 0.30, 0.25),vec3(0.47, 0.37, 0.27),vec3(0.34, 0.30, 0.26),vec3(0.01, 0.24, 0.33),vec3(0.45, 0.32, 0.27),vec3(0.66, 0.58, 0.51),vec3(0.19, 0.24, 0.20),vec3(0.69, 0.49, 0.41),vec3(0.01, 0.34, 0.43),vec3(0.32, 0.42, 0.42),vec3(0.59, 0.63, 0.62),vec3(0.52, 0.39, 0.32),vec3(0.01, 0.26, 0.35),vec3(0.36, 0.39, 0.35),vec3(0.01, 0.26, 0.37),vec3(0.00, 0.23, 0.31),vec3(0.27, 0.28, 0.27),vec3(0.25, 0.30, 0.15),vec3(0.27, 0.38, 0.20),vec3(0.55, 0.36, 0.29),vec3(0.28, 0.30, 0.25),vec3(0.01, 0.22, 0.31),vec3(0.36, 0.37, 0.27),vec3(0.79, 0.73, 0.71),vec3(-0.00, 0.03, 0.04),vec3(0.28, 0.45, 0.26),vec3(0.58, 0.34, 0.90),vec3(0.72, 0.62, 0.59),vec3(0.20, 0.26, 0.20),vec3(0.01, 0.25, 0.34),vec3(0.30, 0.39, 0.30),vec3(0.15, 0.24, 0.19),vec3(0.59, 0.58, 0.60),vec3(0.01, 0.27, 0.37),vec3(0.46, 0.40, 0.35),vec3(0.66, 0.48, 0.32),vec3(0.27, 0.41, 0.43),vec3(0.75, 0.51, 0.43),vec3(0.65, 0.64, 0.60),vec3(0.70, 0.45, 0.35),vec3(0.64, 0.63, 0.44),vec3(0.01, 0.36, 0.47),vec3(0.18, 0.26, 0.20),vec3(0.78, 0.78, 0.74),vec3(-0.00, 0.15, 0.23),vec3(0.34, 0.30, 0.26),vec3(0.50, 0.42, 0.34),vec3(0.56, 0.40, 0.33),vec3(0.33, 0.24, 0.20));



//Mona Lisa
// // Number of Gaussians
// const int NUM_GAUSSIANS = 100;
// // Dimensions [x_min, x_max, y_min, y_max]
// float dim[4] = float[4](-5.0,5.0,-7.552816901408451,7.552816901408451);
// // Centers (x, y coordinates)
// vec2 gauss_centers[NUM_GAUSSIANS] = vec2[NUM_GAUSSIANS](vec2(4.49, -1.98),vec2(2.42, -6.77),vec2(4.68, 0.13),vec2(-0.14, 2.64),vec2(3.79, 4.90),vec2(0.90, 2.64),vec2(-0.82, -6.77),vec2(0.62, -3.32),vec2(-3.32, -3.62),vec2(2.46, 6.15),vec2(-3.74, -4.51),vec2(-0.52, -5.23),vec2(6.18, -5.60),vec2(-0.84, 2.87),vec2(0.74, 7.20),vec2(-1.26, 0.04),vec2(-5.04, -4.65),vec2(-3.43, 3.56),vec2(0.09, 4.94),vec2(6.28, -2.04),vec2(3.85, 1.12),vec2(-1.38, -0.04),vec2(2.07, 0.13),vec2(-2.38, 4.29),vec2(-0.17, 6.79),vec2(3.29, 0.90),vec2(-0.77, 4.93),vec2(1.09, -6.91),vec2(-4.29, -0.51),vec2(1.78, -0.91),vec2(-0.69, -4.63),vec2(-0.56, -0.22),vec2(-0.87, 3.76),vec2(4.89, 5.35),vec2(-3.47, 6.22),vec2(4.74, -2.95),vec2(4.41, -1.16),vec2(-0.84, -1.18),vec2(3.16, 7.19),vec2(1.56, 5.82),vec2(-0.28, -4.46),vec2(-2.18, 2.15),vec2(3.47, -4.76),vec2(1.47, 0.92),vec2(-4.63, -6.61),vec2(-2.91, -2.42),vec2(0.30, -0.40),vec2(2.51, 5.01),vec2(-0.64, 0.51),vec2(-6.02, 3.63),vec2(-1.70, 5.32),vec2(-1.99, -1.09),vec2(3.90, -8.71),vec2(0.79, 1.13),vec2(-3.28, 0.17),vec2(3.69, 5.95),vec2(6.01, -8.75),vec2(0.73, 0.00),vec2(1.73, -5.13),vec2(-1.09, 0.66),vec2(4.60, 7.30),vec2(1.79, 6.90),vec2(-4.22, -1.74),vec2(3.91, 3.89),vec2(6.05, -0.30),vec2(-5.93, -3.88),vec2(-3.47, 2.80),vec2(-0.71, -2.50),vec2(-2.94, -7.30),vec2(-4.41, 3.68),vec2(0.97, -4.88),vec2(-2.91, 1.78),vec2(-0.02, -0.29),vec2(2.57, -3.50),vec2(-3.46, 4.93),vec2(-2.02, -4.15),vec2(-1.27, 7.61),vec2(5.74, 3.98),vec2(0.17, 0.95),vec2(0.10, 3.61),vec2(-2.94, 7.37),vec2(-1.22, -4.40),vec2(-2.00, -3.82),vec2(-2.08, -5.41),vec2(2.29, -1.51),vec2(-4.68, 5.37),vec2(-3.39, -5.57),vec2(-0.60, 1.08),vec2(-4.08, 1.10),vec2(4.34, 2.49),vec2(0.03, -4.79),vec2(-1.24, 6.46),vec2(-2.26, 5.69),vec2(2.73, 2.38),vec2(4.05, -6.40),vec2(2.39, 3.68),vec2(0.23, -3.95),vec2(-4.57, 7.11),vec2(-0.30, 1.69),vec2(0.26, 0.07));
// // Sigmas (scales)
// vec2 gauss_sigmas[NUM_GAUSSIANS] = vec2[NUM_GAUSSIANS](vec2(0.75, 1.15),vec2(0.41, 0.41),vec2(0.43, 0.52),vec2(0.49, 0.25),vec2(0.60, 0.49),vec2(0.61, 0.68),vec2(0.66, 0.67),vec2(0.36, 0.45),vec2(0.74, 0.54),vec2(0.55, 0.48),vec2(0.19, 0.13),vec2(0.62, 0.41),vec2(0.24, 0.24),vec2(0.18, 0.59),vec2(0.58, 0.73),vec2(0.45, 0.60),vec2(0.62, 0.71),vec2(0.40, 0.32),vec2(0.60, 0.33),vec2(0.23, 0.22),vec2(0.59, 0.64),vec2(0.25, 0.28),vec2(0.51, 0.19),vec2(0.42, 0.47),vec2(0.52, 0.53),vec2(0.29, 0.14),vec2(0.42, 0.45),vec2(0.64, 0.57),vec2(0.68, 0.40),vec2(0.62, 0.20),vec2(0.13, 0.18),vec2(0.40, 0.33),vec2(0.35, 0.49),vec2(0.53, 0.80),vec2(0.60, 0.54),vec2(0.08, 0.21),vec2(0.18, 0.13),vec2(0.42, 0.30),vec2(0.67, 0.54),vec2(0.62, 0.25),vec2(0.50, 0.14),vec2(0.52, 0.60),vec2(0.06, 0.07),vec2(0.49, 0.47),vec2(0.73, 0.63),vec2(0.35, 0.30),vec2(0.35, 0.13),vec2(0.56, 0.55),vec2(0.37, 0.27),vec2(0.26, 0.26),vec2(0.18, 0.67),vec2(0.45, 0.68),vec2(0.25, 0.24),vec2(0.24, 0.55),vec2(0.45, 0.50),vec2(0.67, 0.54),vec2(0.24, 0.23),vec2(0.45, 0.42),vec2(0.66, 0.48),vec2(0.15, 0.29),vec2(0.58, 0.73),vec2(0.57, 0.65),vec2(0.72, 0.43),vec2(0.62, 0.51),vec2(0.28, 0.24),vec2(0.27, 0.26),vec2(0.80, 0.39),vec2(0.72, 0.57),vec2(0.87, 0.66),vec2(0.48, 0.73),vec2(0.38, 0.25),vec2(0.62, 0.26),vec2(0.45, 0.70),vec2(1.28, 1.01),vec2(0.63, 0.56),vec2(0.48, 0.22),vec2(0.63, 0.48),vec2(0.49, 0.55),vec2(0.42, 0.56),vec2(0.37, 0.47),vec2(0.68, 0.60),vec2(0.41, 0.38),vec2(0.39, 0.13),vec2(0.41, 0.52),vec2(0.65, 0.29),vec2(0.53, 0.70),vec2(0.61, 0.72),vec2(0.37, 0.20),vec2(0.71, 0.64),vec2(0.62, 0.36),vec2(0.33, 0.08),vec2(0.60, 0.47),vec2(0.51, 0.68),vec2(0.61, 0.65),vec2(0.69, 0.77),vec2(0.44, 0.37),vec2(0.24, 0.23),vec2(0.60, 0.74),vec2(0.13, 0.17),vec2(0.43, 0.55));
// // Rotation angles (thetas)
// float gauss_thetas[NUM_GAUSSIANS] = float[NUM_GAUSSIANS](0.33,0.24,0.41,0.32,-0.19,-0.13,-0.01,-0.25,0.26,0.23,0.16,-0.27,0.06,0.47,-0.07,-0.10,0.24,-0.27,-0.77,-0.07,-0.33,0.38,0.36,0.29,-0.03,-0.53,-0.18,-0.93,-0.59,0.62,0.35,-0.12,-0.38,-0.05,0.21,0.24,-0.48,-0.57,-0.53,-0.85,-0.47,0.07,-0.34,0.01,-1.16,-0.00,0.34,-0.60,0.61,0.11,-0.49,-0.02,0.02,-0.00,-0.03,0.47,0.05,0.36,-0.06,-0.22,0.45,-0.23,0.96,-0.28,0.18,0.21,0.35,0.45,0.26,-0.21,0.10,-0.01,0.04,-0.61,0.33,0.13,0.22,-0.04,-0.18,-0.52,-0.36,0.28,-0.01,-0.19,0.60,-0.23,0.42,0.58,0.02,-0.50,-0.52,-0.12,-0.10,-0.10,0.13,-0.35,0.14,-0.48,0.74,-0.05);
// // Colors (RGB)
// vec3 gauss_colors[NUM_GAUSSIANS] = vec3[NUM_GAUSSIANS](vec3(0.10, 0.04, 0.04),vec3(0.07, 0.02, 0.04),vec3(0.39, 0.19, 0.05),vec3(0.58, 0.32, 0.07),vec3(0.51, 0.43, 0.16),vec3(0.11, 0.01, 0.05),vec3(0.11, 0.05, 0.07),vec3(0.05, 0.02, 0.02),vec3(0.28, 0.15, 0.10),vec3(0.38, 0.29, 0.12),vec3(0.02, 0.03, 0.04),vec3(0.71, 0.31, 0.10),vec3(0.36, 0.04, 0.56),vec3(0.67, 0.43, 0.15),vec3(0.40, 0.35, 0.14),vec3(0.47, 0.11, 0.07),vec3(0.08, 0.05, 0.06),vec3(0.21, 0.20, 0.09),vec3(0.79, 0.44, 0.11),vec3(0.19, 0.78, 0.24),vec3(0.45, 0.34, 0.09),vec3(0.45, 0.58, 0.11),vec3(0.58, 0.35, 0.13),vec3(0.67, 0.54, 0.23),vec3(0.44, 0.38, 0.16),vec3(0.33, 0.28, 0.06),vec3(1.01, 0.79, 0.25),vec3(0.09, 0.03, 0.05),vec3(0.46, 0.19, 0.08),vec3(0.19, 0.10, 0.09),vec3(0.36, 0.25, 0.04),vec3(0.60, 0.66, 0.18),vec3(0.83, 0.52, 0.16),vec3(0.56, 0.44, 0.10),vec3(0.50, 0.42, 0.18),vec3(0.09, 0.06, 0.04),vec3(0.36, 0.10, 0.01),vec3(0.21, 0.16, 0.06),vec3(0.48, 0.41, 0.17),vec3(0.49, 0.41, 0.15),vec3(0.75, 0.47, 0.11),vec3(0.31, 0.21, 0.12),vec3(0.07, 0.01, 0.06),vec3(0.28, 0.08, 0.06),vec3(0.09, 0.04, 0.05),vec3(0.19, 0.10, 0.08),vec3(0.27, 0.28, 0.05),vec3(0.60, 0.49, 0.21),vec3(0.55, 0.58, 0.18),vec3(0.76, 0.51, -0.01),vec3(0.46, 0.40, 0.19),vec3(0.17, 0.10, 0.08),vec3(0.80, 0.38, 0.07),vec3(0.47, 0.31, 0.04),vec3(0.42, 0.28, 0.08),vec3(0.52, 0.44, 0.17),vec3(0.06, 0.77, 0.34),vec3(0.65, 0.26, 0.06),vec3(0.24, 0.09, 0.07),vec3(0.33, 0.33, 0.07),vec3(0.46, 0.42, 0.16),vec3(0.47, 0.39, 0.16),vec3(0.48, 0.27, 0.13),vec3(0.66, 0.58, 0.18),vec3(0.48, 0.03, 0.43),vec3(0.63, 0.86, 0.16),vec3(0.21, 0.18, 0.10),vec3(0.13, 0.07, 0.06),vec3(0.10, 0.05, 0.06),vec3(0.28, 0.25, 0.12),vec3(0.30, 0.15, 0.03),vec3(0.23, 0.24, 0.17),vec3(0.50, 0.16, 0.12),vec3(0.09, 0.04, 0.04),vec3(0.75, 0.62, 0.25),vec3(0.71, 0.47, 0.13),vec3(0.44, 0.42, 0.19),vec3(0.82, 0.74, 0.21),vec3(0.79, 0.47, 0.12),vec3(1.00, 0.64, 0.16),vec3(0.48, 0.41, 0.17),vec3(0.76, 0.47, 0.11),vec3(0.72, 0.52, 0.14),vec3(0.81, 0.43, 0.13),vec3(0.31, 0.17, 0.09),vec3(0.60, 0.52, 0.22),vec3(0.08, 0.04, 0.06),vec3(0.62, 0.42, 0.12),vec3(0.31, 0.25, 0.11),vec3(0.17, 0.17, 0.07),vec3(0.41, 0.17, 0.02),vec3(0.48, 0.38, 0.13),vec3(0.61, 0.50, 0.19),vec3(0.23, 0.20, 0.11),vec3(0.09, 0.03, 0.04),vec3(0.23, 0.20, 0.10),vec3(0.07, 0.03, 0.04),vec3(0.52, 0.45, 0.19),vec3(0.51, 0.29, 0.08),vec3(-0.01, 0.34, 0.10));


//======================================================= Copy-Paste Area End =========================================================

/////////////////////////////////////////////////////
//// Here, you are asked to build the inverse covariance matrix, similar to in the 2DGS_A3_solution.ipynb file.
//// You must create the rotation matrix R, the inverse squared sigma matrix D, and the final inverse covariance matrix. 
/////////////////////////////////////////////////////

// This function builds the inverse covariance matrix
mat2 buildSigmaInv(float theta, vec2 sigma)
{
    mat2 cov_mat = mat2(0, 0, 0, 0);

    /////////// 
    // BEGINNING OF YOUR CODE.
    //////////
    mat2 R = mat2(
        cos(theta), -sin(theta),
        sin(theta),  cos(theta)
    );
    
    mat2 D = mat2(
        1.0 / (sigma.x * sigma.x), 0.0,
        0.0, 1.0 / (sigma.y * sigma.y)
    );

    cov_mat = R * D * transpose(R);
    /////////// 
    // END OF YOUR CODE.
    //////////
    return cov_mat;
}

/////////////////////////////////////////////////////
//// Here, you are asked to fill in the necessary components for calculating each gaussian's contribution to the current pixel's color.
//// You must calculate the position of the pixel relative to the gaussian's center, calculate the contribution exponent (pos^T * sigma_inv * pos) 
//// and finally calculate the Gaussian function value that will control the contribution of this specific gaussian.
/////////////////////////////////////////////////////

void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    float aspect = (dim[1] - dim[0]) / (dim[3] - dim[2]) * iResolution.y / iResolution.x;
    vec2 uv = fragCoord.xy / iResolution.xy; // scale to [0, 1]
    // scale from [-1, 1] to [x_min, x_max] and [y_min, y_max]
    uv.x = mix(dim[0], dim[1], uv.x);
    uv.y = mix(dim[2], dim[3], uv.y);
    if (aspect > 1.0) {
        uv.y *= aspect;
    } else {
        uv.x /= aspect;
    }

    vec3 color = vec3(0.0);

    // Draw bounding box
    float edge = 0.01;
    if (uv.x > dim[0] - edge && uv.x < dim[0] + edge ||
        uv.x > dim[1] - edge && uv.x < dim[1] + edge ||
        ((uv.y > dim[2] - edge && uv.y < dim[2] + edge || uv.y > dim[3] - edge && uv.y < dim[3] + edge) && uv.x > dim[0] && uv.x < dim[1])) {
        color = vec3(1.0, 1.0, 1.0);
    }

    // Animate the Gaussian centers
    uv += smoothstep(0.0, 1.0, cos(iTime)) * cos(iTime + 100.0 * uv.xy) * 3.;

    for (int i = 0; i < NUM_GAUSSIANS; ++i) {
        vec2 center = gauss_centers[i];
        vec2 scale = gauss_sigmas[i];
        float theta = gauss_thetas[i];
        vec3 color_rgb = gauss_colors[i];
        
        // Build inverse covariance matrix
        mat2 sigma_inv = buildSigmaInv(theta, scale);
        float f_x = 0.;

        /////////// 
        // BEGINNING OF YOUR CODE.
        //////////
        vec2 pos = uv - center;
        vec2 sigma_curr = sigma_inv * pos;
        float res = dot(pos, sigma_curr);
        f_x = exp(-0.5 * res);

        /////////// 
        // END OF YOUR CODE.
        //////////
        
        // Add color contribution
        color += f_x * color_rgb;
    }

    fragColor = vec4(color, 1.0);
}


void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
}