<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assignment 4: XPBD Simulation with Springs, Collisions and Ground</title>
    <script id="MathJax-script" defer 
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js">
    </script>
    <style>
        .h1-custom { font-size: 2.25rem; font-weight: 700; margin-bottom: 1.5rem; }
        .h2-custom { font-size: 1.5rem; font-weight: 600; margin-top: 1.5rem; margin-bottom: 1rem; }
        .h3-custom { font-size: 1.25rem; font-weight: 500; margin-top: 1rem; margin-bottom: 0.5rem; }
        .code-inline { font-family: 'Fira Code', Consolas, 'Courier New', monospace; font-size: 1.1rem; font-weight: bold; }
        .link-inline { text-decoration: underline; color: #1d4ed8; font-family: 'Fira Code', Consolas, 'Courier New', monospace; font-size: 1.1rem; font-weight: bold; }
        ul { list-style-type: disc; margin-left: 2rem; padding-left: 1.5rem; }
        li { margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    <h1 class="h1-custom">Assignment 4: XPBD Simulation with Springs, Collisions and Ground</h1>

    <p>Welcome to our exploration of physics-based simulation! In this assignment, you will learn the XPBD (Extended Position-Based Dynamics) simulation algorithm and implement a rope simulation in a GLSL shader. This assignment focuses on simulating a rope using springs, ground constraints, and collision handling. By the end of this assignment, you will have a working simulation that visualizes particle interactions in real time. Let’s dive in!</p>

    <video controls autoplay loop muted style="max-width: 100%; height: auto;">
        <source src="/assignments/A4-ref.mp4" type="video/mp4">
        A4 Reference Video
    </video>
    
    <h2 class="h2-custom">Steps</h2>
    
    <h3 class="h3-custom">Step 1: Spring Constraint (1pt)</h3>
    <p>Implement the positional constraint for elastic springs in <code class="code-inline">spring_constraint()</code>:</p>
    \[ \epsilon_{\text{spring}} = \underbrace{\| \mathbf{x}_a - \mathbf{x}_b \|}_{\text{current length}} - \underbrace{L_0}_{{\text{rest length}}} \]
    
    <h3 class="h3-custom">Step 2: Spring Constraint Gradient (1pt)</h3>
    <p>Derive the constraint Jacobian in <code class="code-inline">spring_constraint_gradient()</code>:</p>
    \[ \nabla\epsilon_{\text{spring}} = \frac{\mathbf{x}_a - \mathbf{x}_b}{\|\mathbf{x}_a - \mathbf{x}_b\|} \]
    <ul>
        <li><strong>Note:</strong> Handle singularity for \( \|\mathbf{x}_a - \mathbf{x}_b\| = 0 \) by returning \((0,0).\)</li>
    </ul>

    <h3 class="h3-custom">Step 3: Solve for Springs with XPBD (2pt)</h3>
    <p>Solve the constrained optimization problem in <code class="code-inline">solve_spring()</code>:</p>
    \[ \lambda = \frac{-\epsilon_{\text{spring}}}{\underbrace{\sum m^{-1}\|∇\epsilon_\text{spring}\|^2}_{\text{inertial term}} + \underbrace{\alpha/\Delta t^2}_{{\text{compliance term}}}} \]
    <ul>
        <li>\( m \) = particle mass (\( m^{-1} \) stored in <code>inv_mass</code>)</li>
        <li>You do not need to calculate the compliance term since it's provided in the code.</li>
    </ul>

    <h3 class="h3-custom">Step 4: Collision Constraint (1pt)</h3>
    <p>Implement <code class="code-inline">collision_constraint()</code>:</p>
    \[ \epsilon_{\text{coll}} = \begin{cases} 
    \| \mathbf{x}_a - \mathbf{x}_b \| - d_{\text{min}} & \text{if } \|\mathbf{x}_a - \mathbf{x}_b\| < d_{\text{min}} \\
    0 & \text{otherwise}
    \end{cases} \]
    <ul>
        <li>It's equivalent to adding a spring when two particles are close enough.</li>
        <li>\( d_{\text{min}} = 0.2 \) is given by the parameter collision_dist </li>
    </ul>

    <h3 class="h3-custom">Step 5: Collision Constraint Gradient (1pt)</h3>
    <p>Compute contact normal vector in <code class="code-inline">collision_constraint_gradient()</code>:</p>
    \[ \nabla\epsilon_{\text{coll}} = \begin{cases}
    \frac{\mathbf{x}_a - \mathbf{x}_b}{\|\mathbf{x}_a - \mathbf{x}_b\|} & \|\mathbf{x}_a - \mathbf{x}_b\| < d_{\text{min}} \\
    \mathbf{0} & \text{otherwise}
    \end{cases} \]

    <h3 class="h3-custom">Step 6: Solve for Collisions with XPBD (2pt)</h3>
    <p>Implement the collision solver in <code class="code-inline">solve_collision_constraint()</code> using XPBD:</p>
    \[ \lambda = \frac{-\epsilon_{\text{coll}}}{\underbrace{\sum m^{-1}\|∇\epsilon_\text{coll}\|^2}_{\text{inertial term}} + \underbrace{\alpha/\Delta t^2}_{{\text{compliance term}}}} \]
    <ul>
        <li>Similar to the spring solver, but now using the collision constraint.</li>
        <li>You again don't need to calculate the compliance term since it's already provided.</li>
    </ul>

    <h3 class="h3-custom">Step 7: Ground Constraint (1pt)</h3>
    <p>Implement ground constraint in <code class="code-inline">ground_constraint()</code> to prevent particles from penetrating the ground surface.</p>

    <p>The ground constraint is defined as:</p>
    \[
    \epsilon_{\text{ground}}(p) =
    \begin{cases}
    \phi(p) - d_{\text{ground}}, & \text{if } \phi(p) < d_{\text{ground}} \\
    0, & \text{otherwise}
    \end{cases}
    \]
    where \( \phi(p) \) represents the signed distance function (SDF) of the ground, and \( d_{\text{ground}} \) is the threshold distance for collision detection. It is given by the parameter ground_collision_dist.</p>


    <h3 class="h3-custom">Step 8: Compute Ground Constraint Gradient (2pt)</h3>
    <p>Implement <code class="code-inline">ground_constraint_gradient()</code> to compute the gradient of the ground constraint, which is necessary for applying position corrections.</p>
    
    <p>The constraint gradient is given by:</p>
    \[
    \nabla \epsilon_{\text{ground}} =
    \begin{cases}
    \nabla \phi(p), & \text{if } \phi(p) < d_{\text{ground}} \\
    (0,0), & \text{otherwise}
    \end{cases}
    \]
    
    <p>Since the signed distance function (SDF) of the ground is defined as:</p>
    \[
    \phi(p) = p_y - (0.1 \sin(2\pi p_x) - 0.5),
    \]
    its gradient is computed as:
    \[
    \frac{\partial \phi}{\partial p_x} = -0.1 \cdot 2\pi \cos(2\pi p_x), \quad
    \frac{\partial \phi}{\partial p_y} = 1.0.
    \]
    

    <h3 class="h3-custom">Step 9: Solve for Ground Constraints with XPBD (2pt)</h3>
    <p>Implement the ground constraint solver in <code class="code-inline">solve_ground_constraint()</code> using XPBD:</p>
    
    \[
    \lambda = \frac{-\epsilon_{\text{ground}}}{\underbrace{m^{-1} \|\nabla\epsilon_{\text{ground}}\|^2}_{\text{inertial term}} + \underbrace{\alpha/\Delta t^2}_{{\text{compliance term}}}}
    \]
    
    You still don't need to calculate the compliance term since it's provided in the code.
    

    <h3 class="h3-custom">Step 10: Solve All Constraints (3pt)</h3>
    <p>Implement the full constraint solver in <code class="code-inline">solve_constraints()</code>using previously defined functions:</p>
    
    <ul>
        <li><strong>Spring constraints:</strong> Solve all spring constraints defined in <code class="code-inline">springs[1]</code> to <code class="code-inline">springs[n_springs - 1]</code> using <code class="code-inline">solve_spring()</code>.</li>
        <li><strong>Ground constraints:</strong> Solve for all particles (except the mouse-controlled particle \( 0 \)) using <code class="code-inline">solve_ground_constraint()</code>.</li>
        <li><strong>Collision constraints:</strong> Solve pairwise collisions for all particles (except the mouse particle \( 0 \)) using <code class="code-inline">solve_collision_constraint()</code>.</li>
    </ul>
        
        
    <h2 class="h2-custom">Creative Expression (2pt)</h2>
    <p class="mb-4">
        In the Creative Expression section of this assignment, you are encouraged to customize the initialization process in the code. Locate the part of the code responsible for initializing the scene or simulation and modify it to create your own version. The creative expression theme for this assignment is <strong>Dynamic Harmony</strong>.
    </p>
    
    <h2 class="h2-custom">Submission</h2>
    <ul class="list-disc pl-8 mb-4">
        <li>Source code for <code>fragment.glsl.</code></li>
        <li>Your default rendered video showcasing the results of your simulated rope.</li>
        <li>Your customized video with the modified initialization for creative expression.</li>
        <li>A concise technical explanation of your implementation.</li>
    </ul>
    
    <h2 class="h2-custom">Sharing Your Work</h2>
    <p>You are encouraged to share your graphical work with the class. If you want to do so, please upload your image to the Ed Discussion post <strong>A4 Gallery: Dynamic Harmony</strong>. This is an excellent opportunity to engage with your peers and gain recognition for your work. Share with us your unique approach to the theme of dynamic harmony!</p>
    
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          if (window.MathJax) {
            MathJax.typesetPromise().then(() => {
              console.log("MathJax successfully rendered formulas!");
            }).catch((err) => console.error("MathJax rendering failed:", err));
          } else {
            console.error("MathJax failed to load.");
          }
        });
      </script>      
</body>
</html>
